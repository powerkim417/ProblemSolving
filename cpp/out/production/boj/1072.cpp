#include <iostream>

using namespace std;

long long x,y,z;

// 이분 탐색
// ____----

bool isChanged(long long m){
    return (z!=(y+m)*100/(x+m)); // 업데이트된 승률이 z에서 바뀌었으면 true
}

int main(void){
    cin>>x>>y;
    z = y*100/x; // 100을 먼저 곱하면서 int 범위 초과하므로 여유있게 long long
    // 최대 판 수(R)을 구하는 아이디어!!!!
    // 0/100=0%인데, 승률이 1%가 되려면 2판을 해야 한다.
    // 1/100=1%인데, 승률이 2%가 되려면 3판을 해야 한다.
    // 98/100=98%인데, 승률이 99%가 되려면 100판을 해야 한다.
    // 99/100=99%인데, 승률이 100%가 되는 것은 불가능

    // 0/10억=0% 인데, 승률이 1%가 되려면 10101011판을 해야 한다.
    // 1천만/10억=1% 인데, 승률이 2%가 되려면 10204082판을 해야 한다.
    // 9.8억-1/10억=97%인데, 승률이 98%가 되려면 50판을 해야 한다.
    // 9.8억/10억=98%인데, 승률이 99%가 되려면 10억판을 해야 한다.
    // 9.9억/10억=99% 인데, 승률이 100%가 되는 것은 불가능

    // 이러한 추세로 미루어 봤을 때, X가 클 수록 판 수가 늘어나고,
    // Y로 확률이 나누어 떨어질 때 필요 판수가 가장 컸다가 Y가 증가할 수록 필요 판 수가 줄어들며,
    // 다시 Y로 확률이 나누어 떨어질 때 필요 판수가 껑충 뛰는 것을 확인할 수 있다.
    // 즉, 가능한 최대 필요 판수는 10억판이며, X=10억일 때 필요 판 수는 Y가 증가함에 따라 10억판을 찍고 다시 조금씩 감소하다가, 99% 확률일 때부터 무한대가 된다.
    int L=0-1, R=1000000000, M;
    while (L+1<R){
        M = (L+R)>>1;
        if (isChanged(M)) R = M;
        else L = M;
    }
    // R이 구하는 값이지만, 함수가 _____ 형태인 경우도 있으므로 값이 변했는지도 확인해야 함
    if (isChanged(R)) cout<<R;
    else cout<<"-1";
    return 0;
}