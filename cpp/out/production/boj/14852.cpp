#include <iostream>

using namespace std;

long long dp[1000001] = {};

/*
각 N마다, 이전 크기에서 나올 수 없는 특수패턴이 2개씩 존재
(ex. N=2일 때는 ㅡ, N=3일 때는 ㅡ. 와 같은 패턴이 뒤집은 형태와 함께 2개씩 존재)
                ..            .ㅡ
특수 패턴을 점화식에 넣기 위해 dp[0] = 1로 설정

dp[0] = 1
dp[1] = dp[0]*2 = 2

dp[2] = dp[1]*2 + dp[0]*3 = 7

dp[3] = dp[2]*2 + dp[1]*3 + dp[0]*2 = 22
      = dp[2]*2 + (dp[2]+dp[1]-dp[0])
      = dp[2]*3 + dp[1] - dp[0]

dp[4] = dp[3]*2 + dp[2]*3 + dp[1]*2 + dp[0]*2
      = dp[3]*2 + (dp[3]+dp[2]-dp[1])
      = dp[3]*3 + dp[2] - dp[1]
...

dp[n] = dp[n-1]*2 // :, ㅣ
      + dp[n-2]*3 // 위ㅡ 아래.., 위.. 아래ㅡ, 위ㅡ아래ㅡ
      + dp[n-3]*2 + ... + dp[0]*2
      = dp[n-1]*3 + dp[n-2] - dp[n-3]
*/

/* 나는 인접 항간의 관계를 이용해서 점화식을 간단하게 만들었지만
일반적인 풀이에서는 dp[n-1]~dp[0]까지 그때그때 다 더해주다가 시간초과가 떴고,
이를 방지하기 위해 뒤에 dp[n-3]*2 + ... + dp[0]*2 부분도 dp로 저장한다고 한다.
dp[2][1] = 2
dp[n][1] = dp[n-1][1] + 2*dp[n-3][0] (부분합 누적)
dp[n][0] = dp[n-1][0]*2 + dp[n-2][0]*3 + dp[n][1] 
*/

int main(void){
    int n;
    cin>>n;
    dp[0] = 1;
    dp[1] = 2;
    dp[2] = 7;
    for (int i=3 ; i<=n ; i++){
        dp[i] = (dp[i-1]*3 + dp[i-2] - dp[i-3] + 1000000007)%1000000007;
        /* dp값이 항상 나머지만을 저장하므로, 더 뒤의 dp값이 더 작은 값으로 저장될 수 있음.
        이 경우 계산값이 음수가 나올 수 있는데, 이 음수값과 실제 값과 저장해야할 dp값은 모두 mod 1000000007 했을 때 같은 값을 가진다!
        즉, mod값이 음수가 나오는걸 막기 위해 1000000007를 더해준다
        */
    }
    cout<<dp[n];
}