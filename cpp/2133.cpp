#include <iostream>

using namespace std;

int dp[31] = {};

/*
타일의 크기는 2인데,
3*N 크기 타일에서 N이 홀수인 경우는 3*N도 홀수이므로
단위가 2인 타일로 만들 수 없다
즉 N으로는 짝수만 올 것이다
*/

/*
IDEA
dp[4]를 예로 들면
dp[2]를 이용한 경우의 수에
ㅡㅡ
ㅣ=ㅣ 형태로 특수한 경우가 위아래 뒤집어서 2개 추가로 생긴다.
dp[6], .. 이후에도
이전 dp값을 이용한 경우의 수에
ㅡㅡ...ㅡ
ㅣ===..ㅣ 형태로 특수한 경우의 수가 2개 추가된다.

패턴 전체가 특수패턴에 해당하는 경우를
dp[0]*(특수[n]) 형태로 손쉽게 계산하기 위해
dp[0] = 1로 둔다.

dp[0] = 1
dp[2] = 3

dp[4] = (dp[2])(특수[2])
      + (dp[0])(특수[4])
      = 3*dp[2] + 2*dp[0] = 11
      
      (이 부분은 나중에 역으로 돌아오면서 깨달음)
      한편 4*dp[2] - dp[0] 도 11이므로 아래에서 도출한 점화식 일반성을 잃지 않는것 확인

dp[6] = (dp[4])(특수[2])
      + (dp[2])(특수[4])
      + (dp[0])(특수[6])
      = 3*dp[4] + 2*dp[2] + 2*dp[0]
      = 3*dp[4] + (dp[4]-dp[2])
      = 4*dp[4] - dp[2]


dp[8] = (dp[6])(특수[2])
      + (dp[4])(특수[4])
      + (dp[2])(특수[6])
      + (dp[0])(특수[8])
      = 3*dp[6] + 2*dp[4] + 2*dp[2] + 2*dp[0]
      = 3*dp[6] + (dp[6]-dp[4])
      = 4*dp[6] - dp[4]

dp[n] = 4*dp[n-2] - dp[n-4]
*/

int main(void){
    int n;
    cin>>n;
    dp[0] = 1;
    dp[2] = 3;
    for (int i=4 ; i<=n ; i++){
        dp[i] = 4*dp[i-2] - dp[i-4];
    }
    cout<<dp[n];
    return 0;
}